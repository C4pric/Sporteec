import sqlite3
import random
import string
import math
sportv = int(input("quel est le sport voulut"))
# Créer une connexion à la base de données SQLite
conn = sqlite3.connect('utilisateurs.db')

# Créer un curseur pour exécuter des commandes SQL
c = conn.cursor()

c.execute('''DELETE FROM utilisateurs''')
conn.commit()
# Créer une table pour stocker les comptes d'utilisateurs
c.execute('''
    CREATE TABLE IF NOT EXISTS utilisateurs (
        id INTEGER PRIMARY KEY,
        nom TEXT NOT NULL,
        latitude INTEGER NOT NULL,
        longitude INTEGER NOT NULL,
        niveau INTEGER NOT NULL,
        etoiles INTEGER NOT NULL,
        sport INTEGER NOT NULL
    )
''')

# Créer 100 utilisateurs avec des données aléatoires
for i in range(1, 101):
    # Générer un nom aléatoire
    nom = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=10))

    # Générer une location aléatoire entre 1 et 10
    latitude = random.randint(-50, 50)
    longitude = random.randint(-50, 50)

    # Générer un niveau aléatoire entre 1 et 50
    niveau = random.randint(1, 5)

    # Générer des étoiles aléatoires entre 1 et 100
    etoiles = random.randint(1, 5)
    sport = random.randint(1, 5)

    # Ajouter l'utilisateur à la table
    c.execute('''
        INSERT INTO utilisateurs (id, nom, latitude,longitude, niveau, etoiles, sport) VALUES (?, ?, ?, ?, ?, ?, ?)
    ''', (i, nom, latitude,longitude, niveau, etoiles,sport))

# Valider les modifications
conn.commit()

# Récupérer toutes les données de la table utilisateurs
c.execute('''
    SELECT id, nom, latitude, longitude, niveau, etoiles, sport FROM utilisateurs
''')

# Récupérer les résultats de la requête
resultats = c.fetchall()

# Créer une liste vide pour stocker les coefficients
coefficients = []

# Récupérer les coordonnées actuelles de l'utilisateur à l'aide de l'API de géolocalisation HTML5
print("Récupération des coordonnées actuelles...")
latitude_actuelle = None
longitude_actuelle = None
try:
    g = geocoder.ip('me')
    latitude_actuelle = g.latlng[0]
    longitude_actuelle = g.latlng[1]
    print("Coordonnées actuelles récupérées :", latitude_actuelle, longitude_actuelle)
except:
    print("Impossible de récupérer les coordonnées actuelles. Veuillez les saisir manuellement.")
    latitude_actuelle = float(input("Entrez votre latitude : "))
    longitude_actuelle = float(input("Entrez votre longitude : "))

# Définir le rayon de la terre en kilomètres
R = 6371

# Parcourir tous les utilisateurs et calculer leur coefficient
for utilisateur in resultats:
    id, nom, latitude, longitude, niveau, etoiles,sport = utilisateur

    # Calculer la distance entre l'utilisateur et les coordonnées actuelles à l'aide de la formule de Haversine
    dlat = math.radians(latitude - latitude_actuelle)
    dlon = math.radians(longitude - longitude_actuelle)
    a = math.sin(dlat / 2) * math.sin(dlat / 2) + math.cos(math.radians(latitude_actuelle)) * math.cos(math.radians(latitude)) * math.sin(dlon / 2) * math.sin(dlon / 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c

    # Calculer le coefficient de l'utilisateur en fonction de la distance, du niveau et des étoiles
    coefficient = distance * 100 + niveau * 20 + etoiles * 10
    if sportv != sport :
        coefficient = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 

    # Ajouter l'utilisateur et son coefficient à la liste
    coefficients.append((id, nom, coefficient, latitude, longitude, niveau, etoiles, distance, sport))

# Trier les coefficients par ordre croissant
coefficients.sort(key=lambda x: x[2])

# Afficher les 10 utilisateurs les plus proches
print("\nLes 10 utilisateurs les plus proches :")
for i in range(min(10, len(coefficients))):
    id, nom, coefficient, latitude, longitude, niveau, etoiles, distance, sport = coefficients[i]
    print("{}. {} (distance : {:.2f} km, niveau : {}, étoiles : {}, sport : {})".format(i+1, nom, distance, niveau, etoiles, sport))

# Fermer la connexion à la base de données
conn.close()
